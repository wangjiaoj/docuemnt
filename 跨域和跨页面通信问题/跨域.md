# 跨域问题
参考文档(前端常见跨域解决方案（全）)[https://segmentfault.com/a/1190000011145364]
## 一、跨越问题由来
当我们使用HTTP协议时，客户端与服务端的通信模式始终是由客户端向服务端发送请求，服务端只负责验证请求并返回响应。它是无状态的，每次都需要验证用户信息，因此需要将用户登录后的相关验证信息保存下来，用于每次http请求的身份验证，这里就用到了cookie来保存用户信息。假如有人获取到了cookie，利用cookie伪装用户信息获取相应资源，就会导致安全问题，为了保证安全，浏览器使用了“同源策略”，这也就导致了跨域问题。

同源指的是"协议 + 域名 + 端口" 三者相同,即便两个不同的域名指向同一个ip地址,也非同源

同源策略限制了以下几种行为
1、cookie、LocalStorage(局部处理器,通过 JS 操作) 和 IndexDB(本地存储) 无法读取
2、DOM(HTML节点树) 和 JS 对象无法获得
3、AJAX 请求发送后,被浏览器拦截

 
## 二、跨域的解决方案：

### 2.1、野路子出身却好用的方式：JSONP；

### 2.2、官方推荐的跨域资源共享方案：CORS；

普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。 

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。

跟JSONP对比优势：
* 1)、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。
* 2)、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。
* 3)、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。

### 2.3、使用HTML5 API：postMessage；

### 2.4、抛弃HTTP，使用：Web Sockets；

### 2.5、 结合iframe跨域：
1、 document.domain + iframe跨域
    修改document.domain的方法只适用于不同子域的框架间的交互
2、 location.hash + iframe跨域

3、 window.name + iframe跨域



### 2.6、 nginx代理跨域、 nodejs中间件代理跨域

### 2.7、图像ping（单向）
    图像ping是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串的形式发送的，而相应可以是任意内容，但通常是像素图或204相应（No Content）。 图像ping有两个主要缺点：首先就是只能发送get请求，其次就是无法访问服务器的响应文本。常用在埋点上。